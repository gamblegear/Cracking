##TreeSummary.txt

1. Two kinds of recursions: recursion starts at the leaf or starts at the null node.

2. A typical thought in Tree is that, the sub-tree is yet another kind of tree.

3. HashMap is a good helper in tree problems. BUT must keep in mind that the return value of each recursive level
   may not be the same of the max/min value stored in the HashMap, which keeps (root, max/min). This is a little
   similar to the "min/max of a stack problem".

4. If Top-down approach is not convenient, say, need to recursively test whether to take the left child or right
   child, then can take a Bottom-up approach. This is also an iterative way.

5. Need to pay attention to the "processing order", whether it should be from right to left or from left to right.

6. When represent tree in array( int[] ), best practice to use "arrayStart" and "arrayEnd = arrays.length - 1" 

7. When making decisions (like comparing values) on leaf node, need to check if this is real leaf node (check Path Sum) - if decided to operate on leaf nodes, then should check not to push null nodes in queue for BFS - 
	(curr.left == null && curr.right == null && sumValue==sum)

8. change the structure of a tree is a dynamic process (flatten binary tree)

9. If there are more than one argument that I want to pass back, can use HashMap as an argument for record and return the most wanted value (baniry tree max path sum - with method in HashMap)

10. When return value that has "accumulated effect" , can use Helper to pass itermediate results and always operate on the root node (see lowest common ancester)

11. Tree problems can usually get solved in recursion. When tree - think about recursion first

Best Time Stock I:
	1. Keep record of the best price at the moment and then slide the pointer

Best Time Stock II:
	1. Find the ascend array

Best Time Stock III:
	1. DP - what is DP, DP is to use another array/2-D array to keep the intermediate value (usually this value is the difference of)
	2. Use two seperate arrays to keep the difference, one is from left and another is from the right, this step is the same idea as Best Time Stock I
	3. The idea to count from both two sides is to make sure they dont overlap

Binary Tree In-order traverse:
	1. Stack<> stack = new Stack<>(), or can use List's addFirst, addLast, removeFirst, removeLast
	
Symmetric Tree:
	1. Split the tree into two parts - left and right
	2. Iterative way is to list all the situations

Minimum Depth of Binary Tree:
	1. If a node has one child (left or right), then this node is NOT leaf node
	
Largest BST in a Binary Tree:
	1. Two approaches - 
		(1) top down, start from each node and check if it's BST, O(n^2)
		(2) bottom up, recursively and keep a TreeNodeHelper(TreeNode root, int BSTSize, int max, int min, boolean isBST), O(n)
	2. When doing BST, always need to keep track of maxValue and minValue - from the definition of BST
	3. If right child isBST == true, need to if the subtree with root node's isBST value

Convert Sorted List to Binary Search Tree:
	1. Use a runner and walker to find the middle node of List
	2. Keep a slow.next = node at beginning, in order to break the list into 2 sub-list
	3. ATTENTION: when dividing a list, think about the situation of only one node
	
Converted Sorted Array to Binary Search Tree:
	1. To find the middle number, use (start + end)/2
	
Construct Binary Tree from Preorder and Inorder Traversal 
	1. The first node from Preorder is the root, use this root to divide trees into left and right by inorder (evrerything left to root will be left subtree in inorder)
	2. Index matters, so maintain a HashMap for inorder

Construct Binary Tree from Inorder and Postorder Traversal 
	1. Same idea as previous one


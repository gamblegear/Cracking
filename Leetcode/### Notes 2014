Best Time Stock I:
	1. Keep record of the best price at the moment and then slide the pointer

Best Time Stock II:
	1. Find the ascend array

Best Time Stock III:
	1. DP - what is DP, DP is to use another array/2-D array to keep the intermediate value (usually this value is the difference of)
	2. Use two seperate arrays to keep the difference, one is from left and another is from the right, this step is the same idea as Best Time Stock I
	3. The idea to count from both two sides is to make sure they dont overlap

Binary Tree In-order traverse:
	1. Stack<> stack = new Stack<>(), or can use List's addFirst, addLast, removeFirst, removeLast
	
Symmetric Tree:
	1. Split the tree into two parts - left and right
	2. Iterative way is to list all the situations

Minimum Depth of Binary Tree:
	1. If a node has one child (left or right), then this node is NOT leaf node
	
Largest BST in a Binary Tree:
	1. Two approaches - 
		(1) top down, start from each node and check if it's BST, O(n^2)
		(2) bottom up, recursively and keep a TreeNodeHelper(TreeNode root, int BSTSize, int max, int min, boolean isBST), O(n)
	2. When doing BST, always need to keep track of maxValue and minValue - from the definition of BST
	3. If right child isBST == true, need to if the subtree with root node's isBST value

Convert Sorted List to Binary Search Tree:
	1. Use a runner and walker to find the middle node of List
	2. Keep a slow.next = node at beginning, in order to break the list into 2 sub-list
	3. ATTENTION: when dividing a list, think about the situation of only one node
	
Converted Sorted Array to Binary Search Tree:
	1. To find the middle number, use (start + end)/2
	
Construct Binary Tree from Preorder and Inorder Traversal 
	1. The first node from Preorder is the root, use this root to divide trees into left and right by inorder (evrerything left to root will be left subtree in inorder)
	2. Index matters, so maintain a HashMap for inorder

Construct Binary Tree from Inorder and Postorder Traversal 
	1. Same idea as previous one

Add Binary:
	1. This is mainly trick with String - toArray(), charAt(), Integer.toString(), String=""
	2. num.charAt(pt) - '0'
	3. Deal with sring1, string2 and carry

Add Two Numbers:
	1. The same idea with "Add Binary" - difference is LinkedList

Same Tree:
	1. Recursively compare two trees
	2. The Base condition is null, remember to return false when one is null while another is NOT null

**Recover Binary Search Tree: (constant space)
	1. Use inorder traverse for all nodes and keep a "prev" node
	2. Dealing with two nodes - think about the relative positions of the two nodes - next to each other or on different branches of the tree. So we will keep track of TWO nodes at the first exception (prev and root), and if we have another exception, we will update the second TreeNode to be root
	3. Traversing a tree iteratively or recursively will both take O(n) space. Morris Traversal will take O(1) space

sqrt()
	1. Binary Search between 0 and (n/2+1)
	2. Since this is integer, mid*mid > target and (mid-1)*(mid-1) < target

Unique Binary Search Trees
	1. This is DP problem
	2. BST has its order, we need to filter out a clue to parse the question - here we use the root of BST - each node in the string could be the root of BST
	3. Once we set the root, we only care about its left sub tree and right sub tree

Unique Binary Search Trees II
	1. Same idea as the previous one, but each time we return ArrayList<TreeNode>
	2. To parse the tree into two sub trees: pass in (start, end) - (start, i-1) and (i+1, end)
	3. Technical part: for(TreeNode node: nodes), if nodes.add(null), still we can go into this loop with node = null

Populating Next Right Pointers in Each Node
	1. This is to provide another way to traverse the tree in 2D - use a slider to slide from the top along left children and use another one to go from left to right
